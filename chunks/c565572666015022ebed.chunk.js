(self.webpackChunk_yoskutik_react_vvm_docs=self.webpackChunk_yoskutik_react_vvm_docs||[]).push([[782],{3283:function(e){e.exports="data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='enable-background:new 0 0 283.842 283.842' viewBox='0 0 283.8 283.8'%3e%3cpath d='m265 23-10-9a56 56 0 0 0-78 5l-29 32c-6 7-5 18 2 24l2 3c8 6 19 5 25-2l28-32c7-7 18-7 25-1l10 9c7 6 7 17 1 24l-62 70c-5 6-14 7-21 3-7-3-17-2-22 5h-1a19 19 0 0 0 6 30 56 56 0 0 0 67-13l62-70c20-23 18-58-5-78z'/%3e%3cpath d='m134 209-3-3c-7-6-18-5-24 2l-29 32c-6 7-17 7-24 1l-10-9c-7-6-8-17-1-24l62-70c5-6 13-7 20-4 8 4 18 2 24-4v-1a18 18 0 0 0-5-28c-23-13-51-8-68 12l-62 69a56 56 0 0 0 5 79l10 9a55 55 0 0 0 78-5l28-32c7-7 6-18-1-24z'/%3e%3c/svg%3e"},6429:function(e,n,o){"use strict";o.d(n,{EK:function(){return I},oP:function(){return Y},ib:function(){return F},LG:function(){return j},hh:function(){return z},Dx:function(){return H}});var i=o(2322),t=o(4944),r=o(1006),s=o(2784),a=o(867),l=o(5894),d=o(3673),c=o(8316);const h=()=>{const e=(0,s.useMemo)((()=>document.querySelector("#root")),[]),[n,o]=(0,s.useState)(!1),t=(0,s.useRef)();(0,s.useEffect)((()=>{const e=new IntersectionObserver((([e])=>{o(0===e.intersectionRatio)})),n=t.current;return e.observe(n),()=>e.unobserve(n)}),[]);const r=(0,c.createPortal)((0,i.jsx)(a.Z,Object.assign({title:n?"Scroll to top":""},{children:(0,i.jsx)(l.Z,Object.assign({onClick:()=>window.scrollTo({top:0,behavior:"smooth"}),style:{pointerEvents:n?void 0:"none"},sx:{transition:"opacity 225ms cubic-bezier(0.4, 0, 0.2, 1) 0ms",transform:"rotate(-90deg)",backgroundColor:"#c2e0ff",opacity:n?1:0,position:"fixed",bottom:20,right:20,"&:hover":{backgroundColor:"#99ccf3"}}},{children:(0,i.jsx)(d.Z,{})}))})),e);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)("div",{ref:t}),r]})};var p=o(75),m=function(e,n,o,i){var t,r=arguments.length,s=r<3?n:null===i?i=Object.getOwnPropertyDescriptor(n,o):i;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(e,n,o,i);else for(var a=e.length-1;a>=0;a--)(t=e[a])&&(s=(r<3?t(s):r>3?t(n,o,s):t(n,o))||s);return r>3&&s&&Object.defineProperty(n,o,s),s},u=function(e,n){if("object"==typeof Reflect&&"function"==typeof Reflect.metadata)return Reflect.metadata(e,n)};class w extends r.ViewModel{constructor(){super(...arguments),this.idToHeading={},this.headingsOrdered=[],this.visibleHeaders=new Set,this.addHeader=(e,n,o)=>{this.headingIds.has(e)&&console.error(`Id already exists: ${e}`),this.headingsOrdered.push({id:e,level:n,text:o.textContent}),this.idToHeading[e]=o},this.toggleHeaderVisibility=(e,n)=>{this.visibleHeaders[n?"add":"delete"](e)},this.scrollToHeading=e=>{this.animatedInfo&&(clearTimeout(this.animatedInfo.timeout),this.animatedInfo.heading.classList.remove("animated"));const n=this.idToHeading[e],{top:o}=n.parentElement.getBoundingClientRect();window.scrollBy({behavior:"smooth",top:o-64-8}),n.classList.add("animated"),this.animatedInfo={heading:n,timeout:setTimeout((()=>{n.classList.remove("animated"),this.animatedInfo=void 0}),2500)}}}get headingIds(){return new Set(this.headingsOrdered.map((e=>e.id)))}get firstVisibleHeader(){var e;return null===(e=this.headingsOrdered.find((e=>this.visibleHeaders.has(e.id))))||void 0===e?void 0:e.id}}m([p.LO.shallow,u("design:type",Array)],w.prototype,"headingsOrdered",void 0),m([p.LO.shallow,u("design:type",Object)],w.prototype,"visibleHeaders",void 0),m([p.Fl,u("design:type",Object),u("design:paramtypes",[])],w.prototype,"headingIds",null),m([p.Fl,u("design:type",String),u("design:paramtypes",[])],w.prototype,"firstVisibleHeader",null),m([p.aD,u("design:type",Object)],w.prototype,"addHeader",void 0),m([p.aD,u("design:type",Object)],w.prototype,"toggleHeaderVisibility",void 0);var v=o(9857);const f=(0,r.childView)()((({viewModel:e})=>{const n=(0,v.lr)()[0].get("heading");return(0,s.useEffect)((()=>{n&&e.scrollToHeading(n)}),[n,e]),null}));var g=o(8621),b=o(5159),x=o(7516);const y=(0,r.childView)()((({text:e,id:n,viewModel:o})=>(0,i.jsx)(g.Z,Object.assign({color:o.firstVisibleHeader===n?"primary":"inherit",style:{backgroundColor:o.firstVisibleHeader===n?"#f0f7ff":void 0,fontWeight:o.firstVisibleHeader===n?"bold":void 0},sx:{transitionProperty:"font-weight, background-color",justifyContent:"flex-start",fontSize:{sm:13,md:14},textTransform:"none",textAlign:"initial",width:"100%"},onClick:()=>o.scrollToHeading(n)},{children:e})))),V=(0,r.childView)()((({viewModel:e})=>(0,i.jsxs)(t.ZP,Object.assign({sx:{borderRight:"1px solid rgba(0, 0, 0, 0.12)",display:{xs:"none",sm:"block"},width:{sm:200,md:250},backgroundColor:"#fff",maxHeight:"100vh",position:"sticky",flexShrink:0,top:0,mt:-8}},{children:[(0,i.jsx)(b.Z,{}),(0,i.jsx)(x.Z,Object.assign({sx:{p:1,overflow:"auto",maxHeight:"calc(100vh - 64px)"}},{children:e.headingsOrdered.map((({id:e,level:n,text:o})=>(0,i.jsx)(x.Z,Object.assign({sx:{pl:2.5*n}},{children:(0,i.jsx)(y,{text:o,id:e})}),e)))}))]})))),j=(0,r.view)(w)((({children:e,hideNavigation:n})=>(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(f,{}),(0,i.jsx)(h,{}),(0,i.jsxs)(t.ZP,Object.assign({container:!0,wrap:"nowrap"},{children:[!n&&(0,i.jsx)(V,{}),(0,i.jsxs)(t.ZP,Object.assign({justifyContent:"center",sx:{overflow:"hidden",padding:"2rem 3rem",width:"100%"}},{children:[(0,i.jsx)(t.ZP,Object.assign({container:!0,direction:"column",gap:8,style:{maxWidth:"100%",width:"1200px",margin:"0 auto"}},{children:e})),(0,i.jsx)("div",{style:{height:"2rem"}})]}))]}))]})));var M=o(8165),k=o(8728),O=o(1989),S=o(3283),C=o.n(S);const E=(0,s.createContext)({level:1}),P=E.Provider,T=e=>{const n=(0,s.useContext)(E);return e&&(n.level=e),n},K=M.F4`
  0% { background-color: rgba(240, 247, 255, 0); }
  30% { background-color: rgba(240, 247, 255, 1); }
  70% { background-color: rgba(240, 247, 255, 1); }
  100% { background-color: rgba(240, 247, 255, 0); }
`,R=(0,k.ZP)(x.Z)`
  border-radius: 0.4rem;
  position: relative;

  &.animated {
    animation: ${K} 0.5s ease-in-out infinite;
  }
  
  img {
    transform: translateY(-50%);
    box-sizing: initial;
    padding-right: 2px;
    position: absolute;
    cursor: pointer;
    left: -18px;
    opacity: 0;
    top: 50%;
  }
  
  &:hover img {
    opacity: 0.6;
  }
`,H=(0,r.childView)()((0,s.forwardRef)((({text:e,variant:n,sx:o,viewModel:t,children:r},a)=>{const{title:l}=T(),d=(0,s.useRef)(),c=(0,s.useRef)(),h=a||d;(0,s.useLayoutEffect)((()=>{const e=[];let o=l;for(;null==o?void 0:o.ref.current;)e.unshift(o.ref.current.textContent),o=o.parent;e.push(h.current.textContent),c.current=e.join(".").toLowerCase().replace(/ /g,"-").replace(/[^a-z-.]/g,""),t.addHeader(c.current,+n.slice(-1)-3,h.current);const i=new IntersectionObserver((e=>{t.toggleHeaderVisibility(c.current,e[0].intersectionRatio>0)}),{rootMargin:"-64px 0px 0px 0px"}),r=h.current;return i.observe(r),()=>i.unobserve(r)}),[]);return(0,i.jsxs)(R,Object.assign({sx:Object.assign({padding:"4px 8px",ml:-1},o),ref:h},{children:[(0,i.jsx)("img",{alt:"",src:C(),width:18,height:18,onClick:()=>{const e=location.hash.split("?")[0];location.hash=`${e}?heading=${c.current}`,t.scrollToHeading(c.current)}}),(0,i.jsx)(O.Z,Object.assign({component:n,variant:n},{children:null!=e?e:r}))]}))}))),F=({title:e,description:n,children:o,forcedLevel:r})=>{const{level:a,title:l}=T(r),d=(0,s.useRef)(),c={level:a+1,title:{parent:l,ref:d}};return(0,i.jsxs)(t.ZP,Object.assign({container:!0,gap:{1:4,2:3,3:2}[a],direction:"column"},{children:[(0,i.jsx)(H,Object.assign({variant:`h${a+2}`,ref:d},{children:e})),n&&(0,i.jsx)(t.ZP,Object.assign({container:!0,gap:2,sx:{mt:{1:-2,2:-1,3:void 0}[a]}},{children:"string"==typeof n?(0,i.jsx)(O.Z,Object.assign({component:"p"},{children:n})):n})),(0,i.jsx)(P,Object.assign({value:c},{children:o}))]}))},I=(0,k.ZP)("code")`
  border: 0.1rem solid rgba(0,0,0,.1);
  background-color: #f6f7f8;
  border-radius: 0.5rem;
  padding: 0 0.3rem;
`;var Z=o(3005),A=o(2074),B=o(2374),D=o(6344),L=o(1076);const W=(0,k.ZP)(x.Z)`
  position: relative;
  
  &:hover .highlighter-copy-button {
    opacity: 1;
  }
`,Y=({code:e,sx:n,style:o,forceShowCopy:t,language:r="tsx"})=>{const[a,d]=(0,s.useState)(!1);return(0,i.jsxs)(W,Object.assign({sx:n},{children:[(0,i.jsx)(Z.Z,Object.assign({customStyle:Object.assign({borderRadius:"0.4rem",boxShadow:"0 1px 4px 0 rgba(0,0,0,0.1)",margin:0},o),language:r,style:A.Z},{children:e})),(void 0===t?e.includes("\n"):t)&&(0,i.jsx)(l.Z,Object.assign({sx:{position:"absolute",top:7,right:7,opacity:0,transitionProperty:"opacity"},className:"highlighter-copy-button",onClick:()=>{navigator.clipboard.writeText(e).then((()=>d(!0)))}},{children:(0,i.jsx)(L.Z,{sx:{fill:"#e0e0e0"}})})),(0,i.jsx)(B.Z,Object.assign({open:a,autoHideDuration:2e3,onClose:()=>d(!1)},{children:(0,i.jsx)(D.Z,Object.assign({onClose:()=>d(!1),severity:"info",sx:{width:"100%"}},{children:"The code was copied!"}))}))]}))};var _=o(885);const z=({text:e="Example",href:n,id:o})=>(0,i.jsxs)(i.Fragment,{children:[" ",(0,i.jsx)(_.Z,Object.assign({href:null!=n?n:`#/examples?heading=${o}`},(null==n?void 0:n.startsWith("http"))&&{target:"_blank",rel:"noreferrer"},{children:e}))]})},1782:function(e,n,o){"use strict";o.r(n),o.d(n,{default:function(){return u}});var i=o(2322),t=o(2784),r=o(1989),s=o(6429),a=o(885),l=o(7516);const d=({example:e,title:n,children:o})=>{const[d,c]=(0,t.useState)(),[h,p]=(0,t.useState)(!1),[m,u]=(0,t.useState)(0),[w,v]=(0,t.useState)(!0),f=(0,t.useRef)();(0,t.useLayoutEffect)((()=>{c(f.current.scrollHeight),v(!1)}),[]);return(0,i.jsxs)(s.ib,Object.assign({description:o&&(0,i.jsx)(r.Z,Object.assign({component:"p"},{children:o})),forcedLevel:3,title:n},{children:[(0,i.jsxs)(a.Z,Object.assign({sx:{cursor:"pointer"},onClick:()=>{h?(u(0),p(!1)):(u(d),p(!0),v(!0))}},{children:[h?"Hide":"Show"," example"]})),(0,i.jsx)(l.Z,Object.assign({style:{transitionDuration:.8*d+"ms",maxHeight:m,marginBottom:h?0:-16},onTransitionEnd:e=>!h&&"max-height"===e.propertyName&&v(!1),ref:f,sx:{transitionProperty:"max-height, margin",borderRadius:"0.4rem",boxSizing:"initial",overflow:"hidden",maxWidth:"100%"}},{children:w&&(0,i.jsx)(s.oP,{code:e,style:{margin:0},forceShowCopy:w})}))]}))};const c=()=>(0,i.jsxs)(s.ib,Object.assign({title:"View and ChildView",description:(0,i.jsxs)(r.Z,Object.assign({component:"p"},{children:["The interfaces of ",(0,i.jsx)(s.EK,{children:"view"})," and ",(0,i.jsx)(s.EK,{children:"childView"})," are pretty much the same. The only difference - the way the view model is typed."]}))},{children:[(0,i.jsxs)(d,Object.assign({title:(0,i.jsxs)(i.Fragment,{children:["Using ",(0,i.jsx)(s.EK,{children:"childView"})]}),example:"import React from 'react';\nimport { view, childView } from '@yoskutik/react-vvm';\nimport { SomeViewModel } from './path-to-view-model';\n\nexport const ChildView = childView<SomeViewModel>()(({ viewModel }) => <div />);\n\n// ChildView does not create a view model and should be located somewhere inside a view.\n// Thus, it can use view's view model.\nexport const View1 = view(SomeViewModel)(({ viewModel }) => (\n  <ChildView />\n));\n\n// It doesn't have to be the direct child\nexport const View2 = view(SomeViewModel)(({ viewModel }) => (\n  <div>\n    <ChildView />\n  </div>\n));\n"},{children:["The component which was created with ",(0,i.jsx)(s.EK,{children:"childView"})," must be used somewhere inside a view of the same view model."]})),(0,i.jsxs)(d,Object.assign({title:"Typing props",example:"import React from 'react';\nimport { view, childView } from '@yoskutik/react-vvm';\nimport { SomeViewModel } from './path-to-view-model';\n\n// View1 and ChildView1 don't have any props\nexport const View1 = view(SomeViewModel)(({ viewModel }) => <div />);\nexport const ChildView1 = childView<SomeViewModel>()(({ viewModel }) => <div />);\n\n// The lines below will not be compiled\n// <View1 viewModel={...} />\n// <ChildView1 viewModel={...} />\n\nexport type Props = {\n  prop1: number; // A required prop\n  prop2?: string; // An optional prop\n}\n\nexport const View2 = view(SomeViewModel)<Props>(({ viewModel, prop1, prop2 }) => (\n  <div />\n));\n\nexport const ChildView = childView<SomeViewModel>()<Props>(({ viewModel, prop1, prop2 }) => (\n  <div />\n));\n\n// And now you can pass the props\n// <View2 prop1={2} prop2=\"prop2\" />\n// <ChildView2 prop1={2} prop2=\"prop2\" />\n"},{children:["By default, ",(0,i.jsx)(s.EK,{children:"view"})," and ",(0,i.jsx)(s.EK,{children:"childView"})," returns an ",(0,i.jsx)(s.EK,{children:"FC"})," component with no props. But you can type it using ",(0,i.jsx)(s.EK,{children:"FC"})," type."]})),(0,i.jsxs)(d,Object.assign({title:"Setting options",example:"import React from 'react';\nimport { view, childView } from '@yoskutik/react-vvm';\nimport { SomeViewModel } from './path-to-view-model';\n\n// View1 and ChildView1 are observers and they are memoized\nexport const View1 = view(SomeViewModel)(({ viewModel }) => <div />);\nexport const ChildView1 = childView<SomeViewModel>()(({ viewModel }) => <div />);\n\n// View2 and ChildView2 are not observers now, but they still memoized with default behaviour\nexport const View2 = view(SomeViewModel)(({ viewModel }) => (\n  <div />\n), { observer: false });\nexport const ChildView2 = childView<SomeViewModel>()(({ viewModel }) => (\n  <div />\n), { observer: false });\n\n\ntype Props = {\n  prop1: number;\n}\n\nconst propsAreEqual = (prevProps: Props, nextProps: Props) => {\n  // logic here\n};\n\n// And this is how you can change propsAreEqual function for the memo\nexport const View3 = view(SomeViewModel)<Props>(({ viewModel }) => (\n  <div />\n), { propsAreEqual });\nexport const ChildView3 = childView<SomeViewModel>()<Props>(({ viewModel }) => (\n  <div />\n), { propsAreEqual });\n"},{children:["By default, ",(0,i.jsx)(s.EK,{children:"view"})," and ",(0,i.jsx)(s.EK,{children:"childView"})," create a memoized observer component. You can make it non-observer or pass ",(0,i.jsx)(s.EK,{children:"propsAreEqual"})," function to the ",(0,i.jsx)(s.EK,{children:"memo"})," HOC."]})),(0,i.jsxs)(d,Object.assign({title:(0,i.jsxs)(i.Fragment,{children:["Using ",(0,i.jsx)(s.EK,{children:"forwardRef"})]}),example:"import React, { forwardRef } from 'react';\nimport { view, childView } from '@yoskutik/react-vvm';\nimport { SomeViewModel } from './path-to-view-model';\n\n// Only ref with no props\nexport const View1 = view(SomeViewModel)<unknown, HTMLDivElement>(\n  forwardRef(({ viewModel }, ref) => (\n    <div ref={ref} />\n  ))\n);\n\nexport const ChildView1 = childView<SomeViewModel>()<unknown, HTMLDivElement>(\n  forwardRef(({ viewModel }, ref) => (\n    <div ref={ref} />\n  ))\n);\n\n\ntype Props = {\n  prop1: number;\n};\n\n// With props\nexport const View2 = view(SomeViewModel)<Props, HTMLDivElement>(\n  forwardRef(({ viewModel, prop1 }, ref) => (\n    <div ref={ref} />\n  ))\n);\n\nexport const ChildView2 = childView<SomeViewModel>()<Props, HTMLDivElement>(\n  forwardRef(({ viewModel, prop1 }, ref) => (\n    <div ref={ref} />\n  ))\n);\n"},{children:["Of course, there's an opportunity to pass a ref via ",(0,i.jsx)(s.EK,{children:"view"})," and ",(0,i.jsx)(s.EK,{children:"childView"}),". You just need to apply ",(0,i.jsx)(s.EK,{children:"forwardRef"})," before applying these functions. Also, if you want to type the component, you have to use second generic."]})),(0,i.jsxs)(d,Object.assign({title:"Using class components",example:"import { ChildViewComponent, view } from '@yoskutik/react-vvm';\nimport { SomeViewModel } from './SomeViewModel';\n\ntype Props = {\n  prop1: number;\n}\n\n// This is a child view. It should be used somewhere inside a view with SomeViewModel view model\nexport class SomeChildView extends ChildViewComponent<SomeViewModel, Props> {\n  render() {\n    return <div>{this.viewModel.field}</div>;\n  }\n}\n\n// But if you want to make it act as view, you can wrap it with the view function\nexport default view(SomeViewModel)<Props>(props => <SomeChildView {...props} />);\n"},{children:["We do not recommend writing new code with class-style components. However, we give you the opportunity to use the MVVM pattern for class components as well. A class component can't be a view, only a ChildView. However, you can additionally use the ",(0,i.jsx)(s.EK,{children:"view"})," function to wrap your ChildView to make it act as view."]}))]}));const h=()=>(0,i.jsxs)(s.ib,Object.assign({title:"Configuration"},{children:[(0,i.jsxs)(d,Object.assign({title:(0,i.jsxs)(i.Fragment,{children:["Configuring ",(0,i.jsx)(s.EK,{children:"vmFactory"})]}),example:"import { configure } from '@yoskutik/react-vvm';\n\nconfigure({\n  vmFactory: VM => {\n    // By default, vmFactory returns new VM();\n\n    const viewModel = new VM();\n\n    // But you can do anything here\n    // Add debug information\n    console.log('view model created:', viewModel);\n\n    // Or process your view model somehow\n    (viewModel as any).__some_special_field = 'some special value';\n\n    // vmFactory must return an instance of a ViewModel\n    return viewModel;\n  },\n})\n"},{children:[(0,i.jsx)(s.EK,{children:"vmFactory"})," tells to views how they should create an instance of a view model. You can configure this function to add debug information or a middleware."]})),(0,i.jsxs)(d,Object.assign({title:(0,i.jsxs)(i.Fragment,{children:["Configuring ",(0,i.jsx)(s.EK,{children:"Wrapper"})]}),example:"import { configure } from '@yoskutik/react-vvm';\nimport { Component, FC, ReactElement } from 'react';\n\n// The Wrapper can be declared both with functional style or as class\n// It must have children as a prop, at it should return a children. Otherwise, your views will not be shown.\nconst FunctionalWrapper: FC<{ children: ReactElement }> = ({ children }) => {\n  // You can add a debug info\n  console.log('view is rendered');\n\n  // You should return children\n  return children;\n};\n\n// You can also use class components\nclass ClassWrapper extends Component<{ children: ReactElement }> {\n  render() {\n    // You can also return processed children\n    return (\n      <div>\n        <span>Wrapper content</span>\n        {this.props.children}\n      </div>\n    );\n  }\n}\n\nconfigure({\n  Wrapper: FunctionalWrapper,\n});\n\nconfigure({\n  Wrapper: ClassWrapper,\n});\n"},{children:["The ",(0,i.jsx)(s.EK,{children:"Wrapper"})," is used to wrap all the views and childViews. By default, the ",(0,i.jsx)(s.EK,{children:"Wrapper"})," is equal to ",(0,i.jsx)(s.EK,{children:"React.Fragment"})," so it doesn't really affect on your application. But you can set any component as wrapper to add debug information or a middleware."]}))]}));const p=()=>(0,i.jsxs)(s.ib,Object.assign({title:"ViewModel"},{children:[(0,i.jsx)(d,Object.assign({title:(0,i.jsxs)(i.Fragment,{children:["Typing ",(0,i.jsx)(s.EK,{children:"parent"})," and ",(0,i.jsx)(s.EK,{children:"viewProps"})]}),example:"import { ViewModel } from '@yoskutik/react-vvm';\nimport type { ParentViewModel } from './ParentViewModel';\nimport type { Props } from './path-to-view-props';\n\n// No typings. parent is unknown, viewProps is unknown\nexport class SomeViewModel1 extends ViewModel {}\n\n// Parent is ParentViewModel, viewProps is unknown\nexport class SomeViewModel2 extends ViewModel<ParentViewModel> {}\n\n// Parent is ParentViewModel, viewProps is Props\nexport class SomeViewModel3 extends ViewModel<ParentViewModel, Props> {}\n\n// Parent is unknown, viewProps is Props\nexport class SomeViewModel4 extends ViewModel<unknown, Props> {}\n"},{children:"View models have link to their parents and also have link to view's props. And you can type both of these fields."})),(0,i.jsx)(d,Object.assign({title:(0,i.jsxs)(i.Fragment,{children:["Using ",(0,i.jsx)(s.EK,{children:"parent"})]}),example:"import { view, ViewModel } from '@yoskutik/react-vvm';\n\nclass ViewModel1 extends ViewModel {\n  doSomething = () => {};\n}\n\nclass ViewModel2 extends ViewModel<ViewModel1> {\n  onClick = () => {\n    this.parent.doSomething();\n  };\n}\n\n// View2 must be located somewhere inside View1. Thus, view model of View1 will be a parent view model for View2\nconst View2 = view(ViewModel2)(({ viewModel }) => (\n  <button onClick={viewModel.onClick} />\n));\n\nconst View1 = view(ViewModel1)(({ viewModel }) => (\n  <div>\n    <View2 />\n  </div>\n));\n"},{children:"If a view is located somewhere inside another view, inner view can use outer one's view model."})),(0,i.jsxs)(d,Object.assign({title:(0,i.jsxs)(i.Fragment,{children:["Observing ",(0,i.jsx)(s.EK,{children:"viewProps"})]}),example:"import { computed, makeObservable } from 'mobx';\nimport { view, childView, ViewModel } from '@yoskutik/react-vvm';\n\ntype Props = {\n  prop1: number;\n  prop2: string;\n}\n\nexport class SomeViewModel extends ViewModel<unknown, Props> {\n  @computed get prop1() {\n    return this.viewProps.prop1;\n  }\n\n  constructor() {\n    super();\n    makeObservable(this);\n\n    // This autorun will be called every time the view gets any new prop, even if the prop1 didn't change\n    this.autorun(() => {\n      console.log(this.viewProps.prop1);\n    });\n\n    // This reaction will be called only if the prop has changed\n    this.reaction(() => this.viewProps.prop1, () => {\n      console.log(this.viewProps.prop1);\n    });\n\n    // This autorun will be called only if the prop has changed\n    this.autorun(() => {\n      console.log(this.prop1);\n    });\n  }\n}\n\nconst SomeChildView = childView<SomeViewModel>()(({ viewModel }) => (\n  <div>\n    {/* If you use the line below, SomeChildView will be re-rendered every time SomeView get any new prop */}\n    {viewModel.viewProps.prop1}\n\n    {/* If you use the line below, SomeChildView will be re-rendered only if prop1 was changed */}\n    {viewModel.prop1}\n  </div>\n));\n\nconst SomeView = view(SomeViewModel)<Props>(() => (\n  <SomeChildView />\n));\n"},{children:["The ",(0,i.jsx)(s.EK,{children:"viewProps"})," field updates every time the view is rendered with new props. The view is memoized, so the amount of updates is minimized. But you need to keep in mind a few rules when you want to observe ",(0,i.jsx)(s.EK,{children:"viewProps"}),". If you are using ",(0,i.jsx)(s.EK,{children:"viewProps"})," inside an ",(0,i.jsx)(s.EK,{children:"autorun"})," or an observer component (",(0,i.jsx)(s.EK,{children:"observer"}),", ",(0,i.jsx)(s.EK,{children:"view"})," or ",(0,i.jsx)(s.EK,{children:"childView"}),"), when the reaction will be called every time the view is rendered with new props."]})),(0,i.jsxs)(d,Object.assign({title:"View lifecycle hooks",example:"import { ViewModel } from '@yoskutik/react-vvm';\n\n// Hooks can be sync and async. Also, they can be decorated with @action or other decorators\nexport class SomeViewModel extends ViewModel {\n  protected onViewMounted() {\n    console.log('View has been mounted. This function is called in the useEffect hook');\n  }\n\n  protected onViewMountedSync() {\n    console.log('View has been mounted. This function is called in the useLayoutEffect hook');\n  }\n\n  protected onViewUpdated() {\n    console.log('View has been updated. This function is called in the useEffect hook');\n  }\n\n  protected onViewUpdatedSync() {\n    console.log('View has been updated. This function is called in the useLayoutEffect hook');\n  }\n\n  protected onViewUnmounted() {\n    console.log('View has been unmounted. This function is called in the useEffect hook');\n  }\n\n  protected onViewUnmountedSync() {\n    console.log('View has been unmounted. This function is called in the useLayoutEffect hook');\n  }\n}\n"},{children:["You add handle some of the view lifecycle state changes, such as mounting, unmounting and updating. There are 3 methods for each hook in the ",(0,i.jsx)(s.EK,{children:"ViewModel"}),"."]})),(0,i.jsxs)(d,Object.assign({title:"Creating reactions",example:"import { intercept, makeObservable, observable, observe, when } from 'mobx';\nimport { ViewModel } from '@yoskutik/react-vvm';\n\nexport class SomeViewModel extends ViewModel {\n  @observable field = 0;\n\n  constructor() {\n    super();\n    makeObservable(this);\n\n    // If you want to create a reaction, please, use this.reaction instead of reaction from the mobx package\n    this.reaction(() => this.field, value => this.doSomething(value));\n\n    // If you want to create an autorun, please, use this.reaction instead of reaction from the mobx package\n    this.autorun(() => {\n      this.doSomething(this.field);\n    });\n\n    // In case you want to create other type of observation, such as observe, intercept or when, you can use\n    // this.addDisposer\n\n    // observe\n    this.addDisposer(\n      observe(this, 'field', ({ newValue }) => this.doSomething(newValue))\n    );\n\n    // intercept\n    this.addDisposer(\n      intercept(this, 'field', change => {\n        this.doSomething(change.newValue);\n        return change;\n      }),\n    );\n\n    // when\n    const w = when(() => this.field === 1);\n    w.then(() => this.doSomething(this.field));\n    this.addDisposer(() => w.cancel());\n  }\n\n  doSomething = (field: number) => {};\n}\n"},{children:["To observe anything in a view model, you ",(0,i.jsx)("i",{children:"should"})," use ViewModel's ",(0,i.jsx)(s.EK,{children:"reaction"}),", "," ",(0,i.jsx)(s.EK,{children:"autorun"})," and ",(0,i.jsx)(s.EK,{children:"addDisposer"})," methods. These methods are added to automatically dispose reactions, when the view becomes unmounted. You can also not to use these methods, but in these case there can be a probability of a memory leak formation."]}))]}));const m=()=>(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(d,Object.assign({title:(0,i.jsxs)(i.Fragment,{children:["Automatic ",(0,i.jsx)(s.EK,{children:"makeObservable"})]}),example:"import { makeObservable, observable } from 'mobx';\nimport { configure, ViewModel } from '@yoskutik/react-vvm';\n\nconfigure({\n  vmFactory: VM => {\n    const viewModel = new VM();\n    makeObservable(viewModel);\n    return viewModel;\n  },\n});\n\nclass SomeViewModel extends ViewModel {\n  @observable field1 = 0;\n\n  protected onViewMounted() {\n    // In case you make view models observable in a vmFactory, and you want to create reactions,\n    // you should do it in the hook\n    this.reaction(() => this.field1, () => {\n      // do something\n    });\n  }\n}\n"},{children:["If you sure that most case your view models will contain observable fields you can make calling ",(0,i.jsx)(s.EK,{children:"makeObservable"})," automatic, so you don't need to call it for each ViewModel separately. But be aware, if you use this code, you should create your reactions in the ",(0,i.jsx)(s.EK,{children:"onViewMounted"})," hook instead of constructor due to the fact that view model will not be observable in it."]})),(0,i.jsx)(d,Object.assign({title:"Enabling DI pattern",example:"import { computed, makeObservable, observable } from 'mobx';\n// It's not necessary to use tsyringe. You can use any library actually\nimport { injectable, container, singleton } from 'tsyringe';\nimport { configure, ViewModel } from '@yoskutik/react-vvm';\n\nconfigure({\n  vmFactory: VM => container.resolve(VM),\n});\n\n// This is an example of common store for the whole application\n@singleton()\nclass SomeOuterClass {\n  @observable field1 = 0;\n\n  @observable field2 = 'field2';\n\n  constructor() {\n    makeObservable(this);\n  }\n\n  doSomething = () => {\n    // do something\n  };\n}\n\n// It can also be any singleton or transient class, containing observable fields is not necessary\n@injectable()\nclass SomeOuterClass2 {\n  @observable field1 = 0;\n\n  @observable field2 = 'field2';\n\n  constructor(private someOuterClass: SomeOuterClass) {\n    makeObservable(this);\n  }\n\n  doSomething = () => {\n    // do something\n  };\n}\n\n@injectable()\nclass SomeViewModel extends ViewModel {\n  @computed get someGetter() {\n    return this.someOuterClass.field1;\n  }\n\n  // And now every ViewModel can access the class via constructor\n  constructor(private someOuterClass: SomeOuterClass, private someOuterClass2: SomeOuterClass2) {\n    super();\n    makeObservable(this);\n  }\n\n  viewModelFunction = () => {\n    this.someOuterClass.doSomething();\n  }\n}\n\n// You can also get an instance of singleton class in the any place of your code\nconst instance = container.resolve(SomeOuterClass);\n"},{children:"I really like the DI pattern. And I highly recommend you to use this pattern if you application is big. This pattern can have a big impact on the ability to scale your application. With the DI you can create common MobX stores for whole application. Such Redux does, but with DI + MobX these stores can be logically separated, can contain methods and can be easily used at any part of your code, including both views and view models."})),(0,i.jsx)(d,Object.assign({title:"Using Error Boundary",example:"import { Component, ReactElement } from 'react';\nimport { configure } from '@yoskutik/react-vvm';\n\nclass ErrorBoundary extends Component<{ children: ReactElement }, { hasError: boolean }> {\n  static getDerivedStateFromError() {\n    return { hasError: true };\n  }\n\n  state = {\n    hasError: false,\n  };\n\n  componentDidCatch(error: Error) {\n    // I recommend you to log the error to avoid situations where your content is disappeared,\n    // and you don't know the reason\n    console.error(error);\n  }\n\n  render() {\n    return !this.state.hasError && this.props.children;\n  };\n}\n\nconfigure({\n  // That's it. And now if one of your components throws an error it will just disappear. At it\n  // will be the only component that disappeared.\n  Wrapper: ErrorBoundary,\n});\n"},{children:"React applications have a few problems. One of them is error handling. If some of your component throws an error and you don't handle it, all the virtual DOM tree will die. FaceBook recommends to use ErrorBoundary to handle such errors. But it can be inconvenient to use it - you should always think where to use it, and there can be a lot of repeating code of using the same error boundary. But with this package you can add error boundaries to all of your views and childViews, so you don't actually have to think about using it at all."}))]});var u=(0,t.memo)((()=>(0,i.jsxs)(s.LG,{children:[(0,i.jsxs)(s.ib,Object.assign({description:"This section contains examples of basic usage of entities with all possible typings and variants.",title:"Basic examples"},{children:[(0,i.jsx)(c,{}),(0,i.jsx)(p,{}),(0,i.jsx)(h,{})]})),(0,i.jsx)(s.ib,Object.assign({description:"This section contains some tricks that can simplify you development process.",title:"Useful examples"},{children:(0,i.jsx)(m,{})})),(0,i.jsx)(s.ib,{title:"Complex examples",description:(0,i.jsxs)(r.Z,Object.assign({component:"p"},{children:["And here's some complex examples of whole React applications with React VVM. You can find them here",(0,i.jsx)(s.hh,{href:"https://github.com/Yoskutik/react-vvm/tree/master/examples",text:"Github"}),"."]}))})]})))}}]);